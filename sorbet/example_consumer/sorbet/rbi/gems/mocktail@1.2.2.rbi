# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mocktail` gem.
# Please instead update this file by running `bin/tapioca gem mocktail`.

# typed: true

# source://mocktail//lib/mocktail/collects_calls.rb#3
module Mocktail
  extend ::Mocktail::DSL

  class << self
    # Stores most transactional state about calls & stubbing configurations
    # Anything returned by this is undocumented and could change at any time, so
    # don't commit code that relies on it!
    #
    # source://mocktail//lib/mocktail.rb#121
    def cabinet; end

    # An alias for Mocktail.explain(double).reference.calls
    # Takes an optional second parameter of the method name to filter only
    # calls to that method
    #
    # source://mocktail//lib/mocktail.rb#114
    sig do
      params(
        double: T.anything,
        method_name: T.nilable(T.any(::String, ::Symbol))
      ).returns(T::Array[::Mocktail::Call])
    end
    def calls(double, method_name = T.unsafe(nil)); end

    # source://mocktail//lib/mocktail.rb#71
    sig { returns(::Mocktail::Matchers::Captor) }
    def captor; end

    # source://mocktail//lib/mocktail.rb#98
    sig { type_parameters(:T).params(thing: T.type_parameter(:T)).returns(::Mocktail::Explanation) }
    def explain(thing); end

    # source://mocktail//lib/mocktail.rb#103
    sig { returns(T::Array[::Mocktail::UnsatisfyingCallExplanation]) }
    def explain_nils; end

    # source://mocktail//lib/mocktail.rb#66
    sig { returns(::Mocktail::MatcherPresentation) }
    def matchers; end

    # Returns an instance of `type` whose implementation is mocked out
    #
    # source://mocktail//lib/mocktail.rb#40
    sig { type_parameters(:T).params(type: T::Class[T.type_parameter(:T)]).returns(T.type_parameter(:T)) }
    def of(type); end

    # Returns an instance of `klass` whose implementation is mocked out AND
    # stubs its constructor to return that fake the next time klass.new is called
    #
    # source://mocktail//lib/mocktail.rb#51
    sig do
      type_parameters(:T)
        .params(
          type: T::Class[T.type_parameter(:T)],
          count: T.nilable(::Integer)
        ).returns(T.type_parameter(:T))
    end
    def of_next(type, count: T.unsafe(nil)); end

    # An alias of of_next that always returns an array of fakes
    #
    # source://mocktail//lib/mocktail.rb#61
    sig do
      type_parameters(:T)
        .params(
          type: T::Class[T.type_parameter(:T)],
          count: T.nilable(::Integer)
        ).returns(T::Array[T.type_parameter(:T)])
    end
    def of_next_with_count(type, count:); end

    # source://mocktail//lib/mocktail.rb#76
    sig { params(matcher: T.class_of(Mocktail::Matchers::Base)).void }
    def register_matcher(matcher); end

    # Replaces every singleton method on `type` with a fake, and when instantiated
    # or included will also fake instance methods
    #
    # source://mocktail//lib/mocktail.rb#83
    sig { params(type: T.any(::Class, ::Module)).void }
    def replace(type); end

    # source://mocktail//lib/mocktail.rb#89
    sig { void }
    def reset; end
  end
end

# source://mocktail//lib/mocktail/errors.rb#12
class Mocktail::AmbiguousDemonstrationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/share/bind.rb#4
module Mocktail::Bind
  class << self
    # source://mocktail//lib/mocktail/share/bind.rb#5
    def call(mock, method_name, *args, **kwargs, &blk); end
  end
end

# source://mocktail//lib/mocktail/value/cabinet.rb#8
class Mocktail::Cabinet
  # @return [Cabinet] a new instance of Cabinet
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#12
  def initialize; end

  # Returns the value of attribute calls.
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#10
  def calls; end

  # source://mocktail//lib/mocktail/value/cabinet.rb#64
  def calls_for_double(double); end

  # Sets the attribute demonstration_in_progress
  #
  # @param value the value to set the attribute demonstration_in_progress to.
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#9
  def demonstration_in_progress=(_arg0); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#47
  def demonstration_in_progress?; end

  # source://mocktail//lib/mocktail/value/cabinet.rb#51
  def double_for_instance(thing); end

  # source://mocktail//lib/mocktail/value/cabinet.rb#20
  def reset!; end

  # source://mocktail//lib/mocktail/value/cabinet.rb#35
  def store_call(call); end

  # source://mocktail//lib/mocktail/value/cabinet.rb#31
  def store_double(double); end

  # source://mocktail//lib/mocktail/value/cabinet.rb#39
  def store_stubbing(stubbing); end

  # source://mocktail//lib/mocktail/value/cabinet.rb#43
  def store_unsatisfying_call(unsatisfying_call); end

  # Returns the value of attribute stubbings.
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#10
  def stubbings; end

  # source://mocktail//lib/mocktail/value/cabinet.rb#58
  def stubbings_for_double(double); end

  # Returns the value of attribute unsatisfying_calls.
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#10
  def unsatisfying_calls; end
end

# source://mocktail//lib/mocktail/value/call.rb#4
class Mocktail::Call < ::T::Struct
  const :singleton, T.nilable(T::Boolean)
  const :double, T.nilable(T.anything)
  const :original_type, T.nilable(T.any(::Module, T::Class[T.anything]))
  const :dry_type, T.nilable(T.any(::Module, T::Class[T.anything]))
  const :method, T.nilable(::Symbol)
  const :original_method, T.nilable(T.any(::Method, ::UnboundMethod))
  const :args, T::Array[T.untyped], default: T.unsafe(nil)
  const :kwargs, T::Hash[::Symbol, T.untyped], default: T.unsafe(nil)
  const :block, T.nilable(T.anything)

  # Because T::Struct compares with referential equality, we need
  # to redefine the equality methods to compare the values of the attributes.
  #
  # source://mocktail//lib/mocktail/value/call.rb#27
  sig { params(other: T.nilable(T.anything)).returns(T::Boolean) }
  def ==(other); end

  # source://mocktail//lib/mocktail/value/call.rb#32
  sig { params(other: T.untyped).returns(T::Boolean) }
  def eql?(other); end

  # source://mocktail//lib/mocktail/value/call.rb#42
  sig { returns(::Integer) }
  def hash; end

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/share/cleans_backtrace.rb#6
class Mocktail::CleansBacktrace
  # source://mocktail//lib/mocktail/share/cleans_backtrace.rb#9
  def clean(error); end
end

# source://mocktail//lib/mocktail/share/cleans_backtrace.rb#7
Mocktail::CleansBacktrace::BASE_PATH = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/collects_calls.rb#4
class Mocktail::CollectsCalls
  # source://mocktail//lib/mocktail/collects_calls.rb#5
  def collect(double, method_name); end
end

# source://mocktail//lib/mocktail/share/creates_identifier.rb#4
class Mocktail::CreatesIdentifier
  # source://mocktail//lib/mocktail/share/creates_identifier.rb#7
  def create(s, default: T.unsafe(nil), max_length: T.unsafe(nil)); end

  private

  # source://mocktail//lib/mocktail/share/creates_identifier.rb#24
  def unreserved(id, default); end
end

# source://mocktail//lib/mocktail/share/creates_identifier.rb#5
Mocktail::CreatesIdentifier::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://mocktail//lib/mocktail/dsl.rb#4
module Mocktail::DSL
  # source://mocktail//lib/mocktail/dsl.rb#18
  sig do
    type_parameters(:T)
      .params(
        ignore_block: T.nilable(T::Boolean),
        ignore_extra_args: T.nilable(T::Boolean),
        ignore_arity: T.nilable(T::Boolean),
        times: T.nilable(::Integer),
        demo: T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(T.type_parameter(:T))
      ).returns(Mocktail::Stubbing[T.type_parameter(:T)])
  end
  def stubs(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end

  # source://mocktail//lib/mocktail/dsl.rb#37
  sig do
    params(
      ignore_block: T.nilable(T::Boolean),
      ignore_extra_args: T.nilable(T::Boolean),
      ignore_arity: T.nilable(T::Boolean),
      times: T.nilable(::Integer),
      demo: T.proc.params(matchers: ::Mocktail::MatcherPresentation).void
    ).void
  end
  def verify(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end
end

# source://mocktail//lib/mocktail/debug.rb#4
module Mocktail::Debug
  class << self
    # It would be easy and bad for the mocktail lib to call something like
    #
    #   double == other_double
    #
    # But if it's a double, that means anyone who stubs that method could change
    # the internal behavior of the library in unexpected ways (as happened here:
    # https://github.com/testdouble/mocktail/issues/7 )
    #
    # For that reason when we run our tests, we also want to blow up if this
    # happens unintentionally. This works in conjunction with the test
    # MockingMethodfulClassesTest, because it mocks every defined method on the
    # mocked BasicObject
    #
    # source://mocktail//lib/mocktail/debug.rb#17
    def guard_against_mocktail_accidentally_calling_mocks_if_debugging!; end
  end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#6
class Mocktail::DeclaresDryClass
  # @return [DeclaresDryClass] a new instance of DeclaresDryClass
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#7
  def initialize; end

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#14
  def declare(type, instance_methods); end

  private

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#76
  def add_stringify_methods!(dry_class, method_name, type, instance_methods); end

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#47
  def define_double_methods!(dry_class, type, instance_methods); end

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#96
  def define_method_missing_errors!(dry_class, type, instance_methods); end
end

# source://mocktail//lib/mocktail/value/demo_config.rb#4
class Mocktail::DemoConfig < ::T::Struct
  const :ignore_block, T.nilable(T::Boolean)
  const :ignore_extra_args, T.nilable(T::Boolean)
  const :ignore_arity, T.nilable(T::Boolean)
  const :times, T.nilable(::Integer)

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#7
class Mocktail::DescribesUnsatisfiedStubbing
  # @return [DescribesUnsatisfiedStubbing] a new instance of DescribesUnsatisfiedStubbing
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#8
  def initialize; end

  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#12
  def describe(dry_call); end
end

# source://mocktail//lib/mocktail/share/determines_matching_calls.rb#6
class Mocktail::DeterminesMatchingCalls
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#7
  def determine(real_call, demo_call, demo_config); end

  private

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#19
  def args_match?(real_args, demo_args, ignore_extra_args); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#44
  def blocks_match?(real_block, demo_block, ignore_block); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#32
  def kwargs_match?(real_kwargs, demo_kwargs, ignore_extra_args); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#56
  def match?(real_arg, demo_arg); end
end

# source://mocktail//lib/mocktail/value/double.rb#4
class Mocktail::Double < ::T::Struct
  const :original_type, T.any(::Module, T::Class[T.anything])
  const :dry_type, T::Class[T.anything]
  const :dry_instance, T.anything
  const :dry_methods, T::Array[::Symbol]

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/double_data.rb#7
class Mocktail::DoubleData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :type, T.any(::Module, T::Class[T.anything])
  const :double, T.anything
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.untyped]]

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/explanation.rb#36
class Mocktail::DoubleExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/value/explanation.rb#41
  sig { params(reference: ::Mocktail::DoubleData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/value/explanation.rb#38
  sig { override.returns(::Mocktail::DoubleData) }
  def reference; end
end

# source://mocktail//lib/mocktail/imitates_type/ensures_imitation_support.rb#4
class Mocktail::EnsuresImitationSupport
  # source://mocktail//lib/mocktail/imitates_type/ensures_imitation_support.rb#5
  def ensure(type); end
end

# source://mocktail//lib/mocktail/errors.rb#4
class Mocktail::Error < ::StandardError; end

# source://mocktail//lib/mocktail/explains_nils.rb#7
class Mocktail::ExplainsNils
  # @return [ExplainsNils] a new instance of ExplainsNils
  #
  # source://mocktail//lib/mocktail/explains_nils.rb#8
  def initialize; end

  # source://mocktail//lib/mocktail/explains_nils.rb#13
  def explain; end
end

# source://mocktail//lib/mocktail/explains_thing.rb#7
class Mocktail::ExplainsThing
  # @return [ExplainsThing] a new instance of ExplainsThing
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#8
  def initialize; end

  # source://mocktail//lib/mocktail/explains_thing.rb#13
  def explain(thing); end

  private

  # source://mocktail//lib/mocktail/explains_thing.rb#47
  def data_for_double(double); end

  # source://mocktail//lib/mocktail/explains_thing.rb#69
  def data_for_type_replacement(type_replacement); end

  # source://mocktail//lib/mocktail/explains_thing.rb#95
  def describe_dry_method(double_data, method); end

  # source://mocktail//lib/mocktail/explains_thing.rb#56
  def double_explanation(double); end

  # source://mocktail//lib/mocktail/explains_thing.rb#27
  def fake_method_explanation_for(thing); end

  # source://mocktail//lib/mocktail/explains_thing.rb#120
  def no_explanation(thing); end

  # source://mocktail//lib/mocktail/explains_thing.rb#82
  def replaced_type_explanation(type_replacement); end
end

# source://mocktail//lib/mocktail/value/explanation.rb#4
class Mocktail::Explanation
  # source://mocktail//lib/mocktail/value/explanation.rb#14
  sig { params(reference: ::Mocktail::ExplanationData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/value/explanation.rb#11
  sig { returns(::String) }
  def message; end

  # source://mocktail//lib/mocktail/value/explanation.rb#8
  sig { returns(::Mocktail::ExplanationData) }
  def reference; end

  # source://mocktail//lib/mocktail/value/explanation.rb#20
  sig { returns(T.class_of(Mocktail::Explanation)) }
  def type; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mocktail//lib/mocktail/value/explanation_data.rb#4
module Mocktail::ExplanationData
  interface!

  # @abstract
  #
  # source://mocktail//lib/mocktail/value/explanation_data.rb#12
  sig { abstract.returns(T::Array[::Mocktail::Call]) }
  def calls; end

  # @abstract
  #
  # source://mocktail//lib/mocktail/value/explanation_data.rb#16
  sig { abstract.returns(T::Array[Mocktail::Stubbing[T.untyped]]) }
  def stubbings; end
end

# source://mocktail//lib/mocktail/value/fake_method_data.rb#4
class Mocktail::FakeMethodData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :receiver, T.anything
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.untyped]]

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/explanation.rb#58
class Mocktail::FakeMethodExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/value/explanation.rb#63
  sig { params(reference: ::Mocktail::FakeMethodData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/value/explanation.rb#60
  sig { override.returns(::Mocktail::FakeMethodData) }
  def reference; end
end

# source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#6
class Mocktail::FindsSatisfaction
  # @return [FindsSatisfaction] a new instance of FindsSatisfaction
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#7
  def initialize; end

  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#11
  def find(dry_call); end
end

# source://mocktail//lib/mocktail/verifies_call/finds_verifiable_calls.rb#6
class Mocktail::FindsVerifiableCalls
  # @return [FindsVerifiableCalls] a new instance of FindsVerifiableCalls
  #
  # source://mocktail//lib/mocktail/verifies_call/finds_verifiable_calls.rb#7
  def initialize; end

  # source://mocktail//lib/mocktail/verifies_call/finds_verifiable_calls.rb#11
  def find(recording, demo_config); end
end

# source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#7
class Mocktail::FulfillsStubbing
  # @return [FulfillsStubbing] a new instance of FulfillsStubbing
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#8
  def initialize; end

  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#13
  def fulfill(dry_call); end

  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#23
  def satisfaction(dry_call); end

  private

  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#31
  def store_unsatisfying_call!(dry_call); end
end

# source://mocktail//lib/mocktail/verifies_call/raises_verification_error/gathers_calls_of_method.rb#4
class Mocktail::GathersCallsOfMethod
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error/gathers_calls_of_method.rb#5
  def gather(dry_call); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#4
class Mocktail::GathersFakeableInstanceMethods
  # source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#5
  def gather(type); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#15
  def ignore?(type, method_name); end

  # source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#19
  def ignored_ancestors; end
end

# source://mocktail//lib/mocktail/grabs_original_method_parameters.rb#2
class Mocktail::GrabsOriginalMethodParameters
  # Sorbet wraps the original method in a sig wrapper, so we need to unwrap it.
  # The value returned from `owner.instance_method(method_name)` does not have
  # the real parameters values available, as they'll have been erased
  #
  # If the method isn't wrapped by Sorbet, this will return the #instance_method,
  # per usual
  #
  # source://mocktail//lib/mocktail/grabs_original_method_parameters.rb#9
  def grab(method); end

  private

  # source://mocktail//lib/mocktail/grabs_original_method_parameters.rb#19
  def sorbet_wrapped_method(method); end
end

# source://mocktail//lib/mocktail/handles_dry_call.rb#8
class Mocktail::HandlesDryCall
  # @return [HandlesDryCall] a new instance of HandlesDryCall
  #
  # source://mocktail//lib/mocktail/handles_dry_call.rb#9
  def initialize; end

  # source://mocktail//lib/mocktail/handles_dry_call.rb#15
  def handle(dry_call); end
end

# source://mocktail//lib/mocktail/handles_dry_new_call.rb#4
class Mocktail::HandlesDryNewCall
  # @return [HandlesDryNewCall] a new instance of HandlesDryNewCall
  #
  # source://mocktail//lib/mocktail/handles_dry_new_call.rb#5
  def initialize; end

  # source://mocktail//lib/mocktail/handles_dry_new_call.rb#12
  def handle(type, args, kwargs, block); end
end

# source://mocktail//lib/mocktail/imitates_type.rb#7
class Mocktail::ImitatesType
  # @return [ImitatesType] a new instance of ImitatesType
  #
  # source://mocktail//lib/mocktail/imitates_type.rb#8
  def initialize; end

  # source://mocktail//lib/mocktail/imitates_type.rb#14
  def imitate(type); end
end

# source://mocktail//lib/mocktail/initializes_mocktail.rb#4
class Mocktail::InitializesMocktail
  # source://mocktail//lib/mocktail/initializes_mocktail.rb#5
  def init; end
end

# source://mocktail//lib/mocktail/errors.rb#14
class Mocktail::InvalidMatcherError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/handles_dry_call/logs_call.rb#4
class Mocktail::LogsCall
  # source://mocktail//lib/mocktail/handles_dry_call/logs_call.rb#5
  def log(dry_call); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double.rb#7
class Mocktail::MakesDouble
  # @return [MakesDouble] a new instance of MakesDouble
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double.rb#8
  def initialize; end

  # source://mocktail//lib/mocktail/imitates_type/makes_double.rb#13
  def make(type); end
end

# source://mocktail//lib/mocktail/matcher_presentation.rb#4
class Mocktail::MatcherPresentation
  sig { returns(T.untyped) }
  def any; end

  sig { type_parameters(:T).params(expecteds: T.type_parameter(:T)).returns(T::Array[T.type_parameter(:T)]) }
  def includes(*expecteds); end

  sig do
    type_parameters(:K, :V)
      .params(
        expecteds: T::Hash[T.type_parameter(:K), T.type_parameter(:V)]
      ).returns(T::Hash[T.type_parameter(:K), T.type_parameter(:V)])
  end
  def includes_hash(*expecteds); end

  sig do
    type_parameters(:K, :V)
      .params(
        expecteds: T.type_parameter(:K)
      ).returns(T::Hash[T.type_parameter(:K), T.type_parameter(:V)])
  end
  def includes_key(*expecteds); end

  sig { type_parameters(:T).params(expecteds: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def includes_string(*expecteds); end

  sig { type_parameters(:T).params(expected: T::Class[T.type_parameter(:T)]).returns(T.type_parameter(:T)) }
  def is_a(expected); end

  sig { params(pattern: T.any(String, Regexp)).returns(String) }
  def matches(pattern); end

  # source://mocktail//lib/mocktail/matcher_presentation.rb#9
  def method_missing(name, *args, **kwargs, &blk); end

  sig { type_parameters(:T).params(unexpected: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def not(unexpected); end

  sig { returns(T.untyped) }
  def numeric; end

  sig { params(blk: T.proc.params(arg: T.untyped).returns(T::Boolean)).returns(T.untyped) }
  def that(&blk); end

  private

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matcher_presentation.rb#5
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://mocktail//lib/mocktail/value/matcher_registry.rb#4
class Mocktail::MatcherRegistry
  # source://mocktail//lib/mocktail/value/matcher_registry.rb#13
  sig { void }
  def initialize; end

  # source://mocktail//lib/mocktail/value/matcher_registry.rb#18
  sig { params(matcher_type: T.class_of(Mocktail::Matchers::Base)).void }
  def add(matcher_type); end

  # source://mocktail//lib/mocktail/value/matcher_registry.rb#23
  sig { params(name: ::Symbol).returns(T.nilable(T.class_of(Mocktail::Matchers::Base))) }
  def get(name); end

  class << self
    # source://mocktail//lib/mocktail/value/matcher_registry.rb#8
    sig { returns(::Mocktail::MatcherRegistry) }
    def instance; end
  end
end

# source://mocktail//lib/mocktail/matchers.rb#4
module Mocktail::Matchers; end

# source://mocktail//lib/mocktail/matchers/any.rb#4
class Mocktail::Matchers::Any < ::Mocktail::Matchers::Base
  # Change this comment to a descriptive one once this is merged:
  # https://github.com/rubocop/rubocop/pull/10551
  #
  # @return [Any] a new instance of Any
  #
  # source://mocktail//lib/mocktail/matchers/any.rb#11
  def initialize; end

  # source://mocktail//lib/mocktail/matchers/any.rb#18
  def inspect; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/any.rb#14
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/any.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/base.rb#4
class Mocktail::Matchers::Base
  # Custom matchers can receive any args, kwargs, or block they want. Usually
  # single-argument, though, so that's defaulted here and in #insepct
  #
  # @return [Base] a new instance of Base
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#7
  def initialize(expected); end

  # source://mocktail//lib/mocktail/matchers/base.rb#19
  def inspect; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#23
  def is_mocktail_matcher?; end

  # @raise [Mocktail::Error]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#15
  def match?(actual); end

  class << self
    # @raise [Mocktail::Error]
    #
    # source://mocktail//lib/mocktail/matchers/base.rb#11
    def matcher_name; end
  end
end

# Captors are conceptually complex implementations, but with a simple usage/purpose:
# They are values the user can create and hold onto that will return a matcher
# and then "capture" the value made by the real call, for later analysis & assertion.
#
# Unlike other matchers, these don't make any useful sense for stubbing, but are
# very useful when asserting complication call verifications
#
# The fact the user will need the reference outside the verification call is
# why this is a top-level method on Mocktail, and not included in the |m| block
# arg to stubs/verify
#
# See Mockito, which is the earliest implementation I know of:
# https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Captor.html
#
# source://mocktail//lib/mocktail/matchers/captor.rb#17
class Mocktail::Matchers::Captor
  # @return [Captor] a new instance of Captor
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#46
  def initialize; end

  # Returns the value of attribute capture.
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#45
  def capture; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#50
  def captured?; end

  # source://mocktail//lib/mocktail/matchers/captor.rb#54
  def value; end
end

# source://mocktail//lib/mocktail/matchers/captor.rb#18
class Mocktail::Matchers::Captor::Capture < ::Mocktail::Matchers::Base
  # @return [Capture] a new instance of Capture
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#25
  def initialize; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#36
  def captured?; end

  # source://mocktail//lib/mocktail/matchers/captor.rb#40
  def inspect; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#30
  def match?(actual); end

  # Returns the value of attribute value.
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#23
  def value; end

  class << self
    # source://mocktail//lib/mocktail/matchers/captor.rb#19
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes.rb#4
class Mocktail::Matchers::Includes < ::Mocktail::Matchers::Base
  # @return [Includes] a new instance of Includes
  #
  # source://mocktail//lib/mocktail/matchers/includes.rb#9
  def initialize(*expecteds); end

  # source://mocktail//lib/mocktail/matchers/includes.rb#22
  def inspect; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/includes.rb#13
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/includes.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes_hash.rb#4
class Mocktail::Matchers::IncludesHash < ::Mocktail::Matchers::Includes
  class << self
    # source://mocktail//lib/mocktail/matchers/includes_hash.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes_key.rb#4
class Mocktail::Matchers::IncludesKey < ::Mocktail::Matchers::Includes
  class << self
    # source://mocktail//lib/mocktail/matchers/includes_key.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes_string.rb#4
class Mocktail::Matchers::IncludesString < ::Mocktail::Matchers::Includes
  class << self
    # source://mocktail//lib/mocktail/matchers/includes_string.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/is_a.rb#4
class Mocktail::Matchers::IsA < ::Mocktail::Matchers::Base
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/is_a.rb#9
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/is_a.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/matches.rb#4
class Mocktail::Matchers::Matches < ::Mocktail::Matchers::Base
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/matches.rb#9
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/matches.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/not.rb#4
class Mocktail::Matchers::Not < ::Mocktail::Matchers::Base
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/not.rb#9
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/not.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/numeric.rb#4
class Mocktail::Matchers::Numeric < ::Mocktail::Matchers::Base
  # Change this comment to a descriptive one once this is merged:
  # https://github.com/rubocop/rubocop/pull/10551
  #
  # @return [Numeric] a new instance of Numeric
  #
  # source://mocktail//lib/mocktail/matchers/numeric.rb#11
  def initialize; end

  # source://mocktail//lib/mocktail/matchers/numeric.rb#18
  def inspect; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/numeric.rb#14
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/numeric.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/that.rb#4
class Mocktail::Matchers::That < ::Mocktail::Matchers::Base
  # @return [That] a new instance of That
  #
  # source://mocktail//lib/mocktail/matchers/that.rb#9
  def initialize(&blk); end

  # source://mocktail//lib/mocktail/matchers/that.rb#22
  def inspect; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/that.rb#16
  def match?(actual); end

  class << self
    # source://mocktail//lib/mocktail/matchers/that.rb#5
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/errors.rb#10
class Mocktail::MissingDemonstrationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/value/explanation.rb#25
class Mocktail::NoExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/value/explanation.rb#30
  sig { params(reference: ::Mocktail::NoExplanationData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/value/explanation.rb#27
  sig { override.returns(::Mocktail::NoExplanationData) }
  def reference; end
end

# source://mocktail//lib/mocktail/value/no_explanation_data.rb#2
class Mocktail::NoExplanationData < ::Struct
  include ::Mocktail::ExplanationData

  # @raise [Error]
  #
  # source://mocktail//lib/mocktail/value/no_explanation_data.rb#8
  def calls; end

  # @raise [Error]
  #
  # source://mocktail//lib/mocktail/value/no_explanation_data.rb#12
  def stubbings; end

  # Returns the value of attribute thing
  #
  # @return [Object] the current value of thing
  def thing; end

  # Sets the attribute thing
  #
  # @param value [Object] the value to set the attribute thing to.
  # @return [Object] the newly set value
  def thing=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://mocktail//lib/mocktail/value/signature.rb#19
class Mocktail::Params < ::Struct
  # @return [Params] a new instance of Params
  #
  # source://mocktail//lib/mocktail/value/signature.rb#26
  def initialize(**params); end

  # Returns the value of attribute all
  #
  # @return [Object] the current value of all
  def all; end

  # Sets the attribute all
  #
  # @param value [Object] the value to set the attribute all to.
  # @return [Object] the newly set value
  def all=(_); end

  # source://mocktail//lib/mocktail/value/signature.rb#33
  def allowed; end

  # Returns the value of attribute optional
  #
  # @return [Object] the current value of optional
  def optional; end

  # Sets the attribute optional
  #
  # @param value [Object] the value to set the attribute optional to.
  # @return [Object] the newly set value
  def optional=(_); end

  # Returns the value of attribute required
  #
  # @return [Object] the current value of required
  def required; end

  # Sets the attribute required
  #
  # @param value [Object] the value to set the attribute required to.
  # @return [Object] the newly set value
  def required=(_); end

  # Returns the value of attribute rest
  #
  # @return [Object] the current value of rest
  def rest; end

  # Sets the attribute rest
  #
  # @param value [Object] the value to set the attribute rest to.
  # @return [Object] the newly set value
  def rest=(_); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/signature.rb#37
  def rest?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#8
class Mocktail::RaisesNeatoNoMethodError
  # @return [RaisesNeatoNoMethodError] a new instance of RaisesNeatoNoMethodError
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#9
  def initialize; end

  # @raise [NoMethodError]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#15
  def call(call); end

  private

  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#55
  def block_param(block); end

  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#71
  def corrections(call); end

  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#61
  def count_repeats(identifiers); end

  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#49
  def kwparams_list(kwargs); end

  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#31
  def params(call); end

  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#41
  def params_list(args); end
end

# source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#8
class Mocktail::RaisesVerificationError
  # @return [RaisesVerificationError] a new instance of RaisesVerificationError
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#9
  def initialize; end

  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#15
  def raise(recording, verifiable_calls, demo_config); end

  private

  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#44
  def describe_other_calls(recording, verifiable_calls, demo_config); end

  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#34
  def describe_verifiable_times_called(demo_config, count); end

  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#59
  def pl(s, count); end
end

# source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#4
class Mocktail::ReconcilesArgsWithParams
  # source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#5
  def reconcile(signature); end

  private

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#12
  def args_match?(arg_params, args); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#17
  def kwargs_match?(kwarg_params, kwargs); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#4
class Mocktail::ReconstructsCall
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#5
  def reconstruct(double:, call_binding:, default_args:, dry_class:, type:, method:, original_method:, signature:); end

  private

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#21
  def args_for(signature, call_binding, default_args); end

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#30
  def kwargs_for(signature, call_binding, default_args); end

  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#39
  def non_default_args(params, default_args); end
end

# source://mocktail//lib/mocktail/records_demonstration.rb#4
class Mocktail::RecordsDemonstration
  # source://mocktail//lib/mocktail/records_demonstration.rb#5
  def record(demonstration, demo_config); end
end

# source://mocktail//lib/mocktail/simulates_argument_error/recreates_message.rb#4
class Mocktail::RecreatesMessage
  # source://mocktail//lib/mocktail/simulates_argument_error/recreates_message.rb#5
  def recreate(signature); end
end

# source://mocktail//lib/mocktail/replaces_type/redefines_new.rb#4
class Mocktail::RedefinesNew
  # @return [RedefinesNew] a new instance of RedefinesNew
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_new.rb#5
  def initialize; end

  # source://mocktail//lib/mocktail/replaces_type/redefines_new.rb#9
  def redefine(type); end
end

# source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#4
class Mocktail::RedefinesSingletonMethods
  # @return [RedefinesSingletonMethods] a new instance of RedefinesSingletonMethods
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#5
  def initialize; end

  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#42
  def declare_singleton_method_missing_errors!(type); end

  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#9
  def redefine(type); end
end

# source://mocktail//lib/mocktail/registers_matcher.rb#4
class Mocktail::RegistersMatcher
  # @return [RegistersMatcher] a new instance of RegistersMatcher
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#5
  def initialize; end

  # source://mocktail//lib/mocktail/registers_matcher.rb#9
  def register(matcher_type); end

  private

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#52
  def invalid_flag?(matcher_type); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#45
  def invalid_match?(matcher_type); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#37
  def invalid_name?(matcher_type); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#33
  def invalid_type?(matcher_type); end
end

# source://mocktail//lib/mocktail/registers_stubbing.rb#6
class Mocktail::RegistersStubbing
  # @return [RegistersStubbing] a new instance of RegistersStubbing
  #
  # source://mocktail//lib/mocktail/registers_stubbing.rb#7
  def initialize; end

  # source://mocktail//lib/mocktail/registers_stubbing.rb#11
  def register(demonstration, demo_config); end
end

# source://mocktail//lib/mocktail/value/explanation.rb#47
class Mocktail::ReplacedTypeExplanation < ::Mocktail::Explanation
  # source://mocktail//lib/mocktail/value/explanation.rb#52
  sig { params(reference: ::Mocktail::TypeReplacementData, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/value/explanation.rb#49
  sig { override.returns(::Mocktail::TypeReplacementData) }
  def reference; end
end

# source://mocktail//lib/mocktail/replaces_next.rb#4
class Mocktail::ReplacesNext
  # @return [ReplacesNext] a new instance of ReplacesNext
  #
  # source://mocktail//lib/mocktail/replaces_next.rb#5
  def initialize; end

  # @raise [UnsupportedMocktail]
  #
  # source://mocktail//lib/mocktail/replaces_next.rb#11
  def replace(type, count); end
end

# source://mocktail//lib/mocktail/replaces_type.rb#8
class Mocktail::ReplacesType
  # @return [ReplacesType] a new instance of ReplacesType
  #
  # source://mocktail//lib/mocktail/replaces_type.rb#9
  def initialize; end

  # source://mocktail//lib/mocktail/replaces_type.rb#16
  def replace(type); end
end

# source://mocktail//lib/mocktail/resets_state.rb#4
class Mocktail::ResetsState
  # source://mocktail//lib/mocktail/resets_state.rb#5
  def reset; end
end

# source://mocktail//lib/mocktail/replaces_type/runs_sorbet_sig_blocks_before_replacement.rb#2
class Mocktail::RunsSorbetSigBlocksBeforeReplacement
  # This is necessary because when Sorbet runs a sig block of a singleton
  # method, it has the net effect of unwrapping/redefining the method. If
  # we try to use Mocktail.replace(Foo) and Foo.bar has a Sorbet sig block,
  # then we'll end up with three "versions" of the same method and no way
  # to keep straight which one == which:
  #
  #  A - Foo.bar, as defined in the original class
  #  B - Foo.bar, as redefined by RedefinesSingletonMethods
  #  C - Foo.bar, as wrapped by sorbet-runtime
  #
  # Initially, Foo.method(:bar) would == C, but after the type
  # replacement, it would == B (with a reference back to C as the original),
  # but after while handling a single dry call, our invocation of
  # GrabsOriginalMethodParameters.grab(Foo.method(:bar)) would invoke the
  # Sorbet `sig` block, which has the net effect of redefining the method back
  # to A.
  #
  # It's very fun and confusing and a great time.
  #
  # source://mocktail//lib/mocktail/replaces_type/runs_sorbet_sig_blocks_before_replacement.rb#21
  def run(type); end
end

# source://mocktail//lib/mocktail/value/signature.rb#4
class Mocktail::Signature < ::Struct
  # Returns the value of attribute block_arg
  #
  # @return [Object] the current value of block_arg
  def block_arg; end

  # Sets the attribute block_arg
  #
  # @param value [Object] the value to set the attribute block_arg to.
  # @return [Object] the newly set value
  def block_arg=(_); end

  # Returns the value of attribute block_param
  #
  # @return [Object] the current value of block_param
  def block_param; end

  # Sets the attribute block_param
  #
  # @param value [Object] the value to set the attribute block_param to.
  # @return [Object] the newly set value
  def block_param=(_); end

  # Returns the value of attribute keyword_args
  #
  # @return [Object] the current value of keyword_args
  def keyword_args; end

  # Sets the attribute keyword_args
  #
  # @param value [Object] the value to set the attribute keyword_args to.
  # @return [Object] the newly set value
  def keyword_args=(_); end

  # Returns the value of attribute keyword_params
  #
  # @return [Object] the current value of keyword_params
  def keyword_params; end

  # Sets the attribute keyword_params
  #
  # @param value [Object] the value to set the attribute keyword_params to.
  # @return [Object] the newly set value
  def keyword_params=(_); end

  # Returns the value of attribute positional_args
  #
  # @return [Object] the current value of positional_args
  def positional_args; end

  # Sets the attribute positional_args
  #
  # @param value [Object] the value to set the attribute positional_args to.
  # @return [Object] the newly set value
  def positional_args=(_); end

  # Returns the value of attribute positional_params
  #
  # @return [Object] the current value of positional_params
  def positional_params; end

  # Sets the attribute positional_params
  #
  # @param value [Object] the value to set the attribute positional_params to.
  # @return [Object] the newly set value
  def positional_params=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://mocktail//lib/mocktail/value/signature.rb#16
Mocktail::Signature::DEFAULT_BLOCK_PARAM = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/value/signature.rb#14
Mocktail::Signature::DEFAULT_REST_ARGS = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/value/signature.rb#15
Mocktail::Signature::DEFAULT_REST_KWARGS = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/simulates_argument_error.rb#10
class Mocktail::SimulatesArgumentError
  # @return [SimulatesArgumentError] a new instance of SimulatesArgumentError
  #
  # source://mocktail//lib/mocktail/simulates_argument_error.rb#11
  def initialize; end

  # source://mocktail//lib/mocktail/simulates_argument_error.rb#19
  def simulate(dry_call); end
end

# source://mocktail//lib/mocktail/share/stringifies_call.rb#4
class Mocktail::StringifiesCall
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#5
  def stringify(call, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#9
  def stringify_multiple(calls, nonzero_message:, zero_message:, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  private

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#39
  def argify(args); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#25
  def args_to_s(call, parens: T.unsafe(nil)); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#54
  def blockify(block, anonymous:); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#44
  def kwargify(kwargs); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#49
  def lambdafy(block); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#64
  def source_locationify(block); end

  # source://mocktail//lib/mocktail/share/stringifies_call.rb#68
  def strip_pwd(path); end
end

# source://mocktail//lib/mocktail/share/stringifies_method_name.rb#4
class Mocktail::StringifiesMethodName
  # source://mocktail//lib/mocktail/share/stringifies_method_name.rb#5
  def stringify(call); end
end

# source://mocktail//lib/mocktail/stringifies_method_signature.rb#4
class Mocktail::StringifiesMethodSignature
  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#5
  def stringify(signature); end

  private

  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#39
  def block(signature); end

  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#27
  def keyword(signature); end

  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#15
  def positional(signature); end
end

# source://mocktail//lib/mocktail/value/stubbing.rb#4
class Mocktail::Stubbing < ::T::Struct
  extend T::Generic

  const :demonstration, T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(MethodReturnType)
  const :demo_config, ::Mocktail::DemoConfig
  prop :satisfaction_count, ::Integer, default: T.unsafe(nil)
  const :recording, ::Mocktail::Call
  prop :effect, T.nilable(T.proc.params(call: ::Mocktail::Call).returns(MethodReturnType))

  # source://mocktail//lib/mocktail/value/stubbing.rb#16
  sig { void }
  def satisfied!; end

  # source://mocktail//lib/mocktail/value/stubbing.rb#21
  sig { params(block: T.proc.params(call: ::Mocktail::Call).returns(MethodReturnType)).void }
  def with(&block); end

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# The TopShelf is where we keep all the more global, dangerous state.
# In particular, this is where Mocktail manages state related to singleton
# method replacements carried out with Mocktail.replace(ClassOrModule)
#
# source://mocktail//lib/mocktail/value/top_shelf.rb#7
class Mocktail::TopShelf
  # @return [TopShelf] a new instance of TopShelf
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#15
  def initialize; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#41
  def new_replaced?(type); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#49
  def of_next_registered?(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#37
  def register_new_replacement!(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#45
  def register_of_next_replacement!(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#57
  def register_singleton_method_replacement!(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#33
  def reset_current_thread!; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#61
  def singleton_methods_replaced?(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#21
  def type_replacement_for(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#27
  def type_replacement_if_exists_for(type); end

  # source://mocktail//lib/mocktail/value/top_shelf.rb#53
  def unregister_of_next_replacement!(type); end

  class << self
    # source://mocktail//lib/mocktail/value/top_shelf.rb#8
    def instance; end
  end
end

# source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#6
class Mocktail::TransformsParams
  # @return [TransformsParams] a new instance of TransformsParams
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#7
  def initialize; end

  # source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#11
  def transform(dry_call, params: T.unsafe(nil)); end

  private

  # source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#43
  def name_unnamed_params(params); end
end

# source://mocktail//lib/mocktail/value/type_replacement.rb#4
class Mocktail::TypeReplacement < ::T::Struct
  const :type, T.any(::Module, T::Class[T.anything])
  prop :original_methods, T.nilable(T::Array[::Method])
  prop :replacement_methods, T.nilable(T::Array[::Method])
  prop :original_new, T.nilable(::Method)
  prop :replacement_new, T.nilable(::Method)

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/type_replacement_data.rb#4
class Mocktail::TypeReplacementData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :type, T.any(::Module, T::Class[T.anything])
  const :replaced_method_names, T::Array[::Symbol]
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.untyped]]

  # source://mocktail//lib/mocktail/value/type_replacement_data.rb#15
  sig { returns(T.any(::Module, T::Class[T.anything])) }
  def double; end

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/errors.rb#6
class Mocktail::UnexpectedError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/value/unsatisfying_call.rb#4
class Mocktail::UnsatisfyingCall < ::T::Struct
  const :call, ::Mocktail::Call
  const :other_stubbings, T::Array[Mocktail::Stubbing[T.untyped]]
  const :backtrace, T::Array[::String]

  class << self
    # source://sorbet-runtime/0.5.10847/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#4
class Mocktail::UnsatisfyingCallExplanation
  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#14
  sig { params(reference: ::Mocktail::UnsatisfyingCall, message: ::String).void }
  def initialize(reference, message); end

  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#11
  sig { returns(::String) }
  def message; end

  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#8
  sig { returns(::Mocktail::UnsatisfyingCall) }
  def reference; end

  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#20
  sig { returns(T.class_of(Mocktail::UnsatisfyingCallExplanation)) }
  def type; end
end

# source://mocktail//lib/mocktail/errors.rb#8
class Mocktail::UnsupportedMocktail < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/version.rb#4
Mocktail::VERSION = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#4
class Mocktail::ValidatesArguments
  # @return [ValidatesArguments] a new instance of ValidatesArguments
  #
  # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#26
  def initialize; end

  # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#30
  def validate(dry_call); end

  class << self
    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#5
    def disable!; end

    # @return [Boolean]
    #
    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#13
    def disabled?; end

    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#9
    def enable!; end

    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#17
    def optional(disable, &blk); end
  end
end

# source://mocktail//lib/mocktail/errors.rb#16
class Mocktail::VerificationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/verifies_call.rb#8
class Mocktail::VerifiesCall
  # @return [VerifiesCall] a new instance of VerifiesCall
  #
  # source://mocktail//lib/mocktail/verifies_call.rb#9
  def initialize; end

  # source://mocktail//lib/mocktail/verifies_call.rb#15
  def verify(demo, demo_config); end

  private

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/verifies_call.rb#27
  def verification_satisfied?(verifiable_call_count, demo_config); end
end

module Mocktail::ExplanationData
  include Kernel
end

class Mocktail::Stubbing
  MethodReturnType = type_member
end
