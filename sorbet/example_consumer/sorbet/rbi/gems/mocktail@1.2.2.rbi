# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mocktail` gem.
# Please instead update this file by running `bin/tapioca gem mocktail`.

# typed: true

# source://mocktail//lib/mocktail/typed.rb#1
module Mocktail
  extend ::Mocktail::DSL

  class << self
    # Stores most transactional state about calls & stubbing configurations
    # Anything returned by this is undocumented and could change at any time, so
    # don't commit code that relies on it!
    #
    # source://mocktail//lib/mocktail.rb#117
    def cabinet; end

    # An alias for Mocktail.explain(double).reference.calls
    # Takes an optional second parameter of the method name to filter only
    # calls to that method
    #
    # source://mocktail//lib/mocktail.rb#109
    def calls(double, method_name = T.unsafe(nil)); end

    # @return [Mocktail::Matchers::Captor]
    #
    # source://mocktail//lib/mocktail.rb#77
    def captor; end

    # @param thing [Object]
    # @return [Explanation]
    #
    # source://mocktail//lib/mocktail.rb#97
    def explain(thing); end

    # @return [Array<Mocktail::UnsatisfyingCallExplanation>]
    #
    # source://mocktail//lib/mocktail.rb#101
    def explain_nils; end

    # @return [Mocktail::MatcherPresentation]
    #
    # source://mocktail//lib/mocktail.rb#73
    def matchers; end

    # Returns an instance of `type` whose implementation is mocked out
    #
    # source://mocktail//lib/mocktail.rb#40
    def of(type); end

    # Returns an instance of `klass` whose implementation is mocked out AND
    # stubs its constructor to return that fake the next time klass.new is called
    #
    # source://mocktail//lib/mocktail.rb#47
    def of_next(type, count: T.unsafe(nil)); end

    # An alias of of_next that always returns an array of fakes
    #
    # source://mocktail//lib/mocktail.rb#69
    def of_next_with_count(type, count); end

    # @param matcher [T.class_of(Mocktail::Matchers::Base)]
    # @return [void]
    #
    # source://mocktail//lib/mocktail.rb#81
    def register_matcher(matcher); end

    # Replaces every singleton method on `type` with a fake, and when instantiated
    # or included will also fake instance methods
    #
    # source://mocktail//lib/mocktail.rb#88
    def replace(type); end

    # @return [void]
    #
    # source://mocktail//lib/mocktail.rb#93
    def reset; end
  end
end

# source://mocktail//lib/mocktail/errors.rb#12
class Mocktail::AmbiguousDemonstrationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail.rb#36
Mocktail::BASE_PATH = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/share/bind.rb#4
module Mocktail::Bind
  class << self
    # sig intentionally omitted, because the wrapper will cause infinite recursion if certain methods are mocked
    #
    # source://mocktail//lib/mocktail/share/bind.rb#6
    def call(mock, method_name, *args, **kwargs, &blk); end
  end
end

# source://mocktail//lib/mocktail/value/cabinet.rb#8
class Mocktail::Cabinet
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#19
  def initialize; end

  # @return [Array<Call>]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#13
  def calls; end

  # @param double [Double]
  # @return [Array<Call>]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#71
  def calls_for_double(double); end

  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#11
  def demonstration_in_progress=(_arg0); end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#54
  def demonstration_in_progress?; end

  # @param thing [T.anything]
  # @return [Double, nil]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#58
  def double_for_instance(thing); end

  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#27
  def reset!; end

  # @param call [Call]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#42
  def store_call(call); end

  # @param double [Double]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#38
  def store_double(double); end

  # @param stubbing [Stubbing[T.anything]]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#46
  def store_stubbing(stubbing); end

  # @param unsatisfying_call [UnsatisfyingCall]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#50
  def store_unsatisfying_call(unsatisfying_call); end

  # @return [Array<Stubbing[T.anything]>]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#15
  def stubbings; end

  # @param double [Double]
  # @return [Array<Stubbing[T.anything]>]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#65
  def stubbings_for_double(double); end

  # @return [Array<UnsatisfyingCall>]
  #
  # source://mocktail//lib/mocktail/value/cabinet.rb#17
  def unsatisfying_calls; end
end

# source://mocktail//lib/mocktail/value/call.rb#4
class Mocktail::Call < ::T::Struct
  const :singleton, T.nilable(T::Boolean)
  const :double, T.untyped, default: T.unsafe(nil)
  const :original_type, T.nilable(T.any(::Module, T::Class[T.anything]))
  const :dry_type, T.nilable(T.any(::Module, T::Class[T.anything]))
  const :method, T.nilable(::Symbol)
  const :original_method, T.nilable(T.any(::Method, ::UnboundMethod))
  const :args, T::Array[T.untyped], default: T.unsafe(nil)
  const :kwargs, T::Hash[::Symbol, T.untyped], default: T.unsafe(nil)
  const :block, T.nilable(::Proc)

  # Because T::Struct compares with referential equality, we need
  # to redefine the equality methods to compare the values of the attributes.
  #
  # source://mocktail//lib/mocktail/value/call.rb#26
  def ==(other); end

  # @param other [T.anything]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/call.rb#30
  def eql?(other); end

  # @return [Integer]
  #
  # source://mocktail//lib/mocktail/value/call.rb#44
  def hash; end

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/share/cleans_backtrace.rb#4
class Mocktail::CleansBacktrace
  # @param error [T.all(T.type_parameter(:T), StandardError)]
  # @return [T.type_parameter(:T)]
  #
  # source://mocktail//lib/mocktail/share/cleans_backtrace.rb#7
  def clean(error); end
end

# source://mocktail//lib/mocktail/collects_calls.rb#4
class Mocktail::CollectsCalls
  # @param double [Object]
  # @param method_name [Symbol, nil]
  # @return [Array<Call>]
  #
  # source://mocktail//lib/mocktail/collects_calls.rb#7
  def collect(double, method_name); end
end

# source://mocktail//lib/mocktail/share/creates_identifier.rb#4
class Mocktail::CreatesIdentifier
  # @param s [T.anything]
  # @param default [String]
  # @param max_length [Integer]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/creates_identifier.rb#9
  def create(s, default: T.unsafe(nil), max_length: T.unsafe(nil)); end

  private

  # @param id [String]
  # @param default [String]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/creates_identifier.rb#31
  def unreserved(id, default); end
end

# source://mocktail//lib/mocktail/share/creates_identifier.rb#7
Mocktail::CreatesIdentifier::KEYWORDS = T.let(T.unsafe(nil), Array)

# source://mocktail//lib/mocktail/dsl.rb#4
module Mocktail::DSL
  # @param ignore_block [Boolean]
  # @param ignore_extra_args [Boolean]
  # @param ignore_arity [Boolean]
  # @param times [Integer, nil]
  # @param demo [T.proc.params(matchers: Mocktail::MatcherPresentation).returns(T.type_parameter(:T))]
  # @return [Mocktail::Stubbing[T.type_parameter(:T)]]
  #
  # source://mocktail//lib/mocktail/dsl.rb#7
  def stubs(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end

  # @param ignore_block [Boolean]
  # @param ignore_extra_args [Boolean]
  # @param ignore_arity [Boolean]
  # @param times [Integer, nil]
  # @param demo [T.proc.params(matchers: Mocktail::MatcherPresentation).void]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/dsl.rb#16
  def verify(ignore_block: T.unsafe(nil), ignore_extra_args: T.unsafe(nil), ignore_arity: T.unsafe(nil), times: T.unsafe(nil), &demo); end
end

# source://mocktail//lib/mocktail/debug.rb#4
module Mocktail::Debug
  class << self
    # It would be easy and bad for the mocktail lib to call something like
    #
    #   double == other_double
    #
    # But if it's a double, that means anyone who stubs that method could change
    # the internal behavior of the library in unexpected ways (as happened here:
    # https://github.com/testdouble/mocktail/issues/7 )
    #
    # For that reason when we run our tests, we also want to blow up if this
    # happens unintentionally. This works in conjunction with the test
    # MockingMethodfulClassesTest, because it mocks every defined method on the
    # mocked BasicObject
    #
    # @return [void]
    #
    # source://mocktail//lib/mocktail/debug.rb#20
    def guard_against_mocktail_accidentally_calling_mocks_if_debugging!; end
  end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#6
class Mocktail::DeclaresDryClass
  # @return [void] a new instance of DeclaresDryClass
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#11
  def initialize; end

  # @param type [T.all(T.type_parameter(:T), T::Class[T.anything])]
  # @param instance_methods [Array<Symbol>]
  # @return [T.type_parameter(:T)]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#18
  def declare(type, instance_methods); end

  private

  # These have special implementations, but if the user defines
  # any of them on the object itself, then they'll be replaced with normal
  # mocked methods. YMMV
  #
  # @param dry_class [T::Class[Object]]
  # @param type [T::Class[T.anything], Module]
  # @param instance_methods [Array<Symbol>]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#50
  def add_more_methods!(dry_class, type, instance_methods); end

  # @param dry_class [T::Class[Object]]
  # @param method_name [Symbol]
  # @param type [T::Class[T.anything], Module]
  # @param instance_methods [Array<Symbol>]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#87
  def add_stringify_methods!(dry_class, method_name, type, instance_methods); end

  # @param dry_class [T::Class[Object]]
  # @param type [T::Class[T.anything], Module]
  # @param instance_methods [Array<Symbol>]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#58
  def define_double_methods!(dry_class, type, instance_methods); end

  # @param dry_class [T::Class[Object]]
  # @param type [T::Class[T.anything], Module]
  # @param instance_methods [Array<Symbol>]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#107
  def define_method_missing_errors!(dry_class, type, instance_methods); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class.rb#9
Mocktail::DeclaresDryClass::DEFAULT_ANCESTORS = T.let(T.unsafe(nil), Array)

# source://mocktail//lib/mocktail/value/demo_config.rb#4
class Mocktail::DemoConfig < ::T::Struct
  const :ignore_block, T::Boolean, default: T.unsafe(nil)
  const :ignore_extra_args, T::Boolean, default: T.unsafe(nil)
  const :ignore_arity, T::Boolean, default: T.unsafe(nil)
  const :times, T.nilable(::Integer), default: T.unsafe(nil)

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#7
class Mocktail::DescribesUnsatisfiedStubbing
  # @return [void] a new instance of DescribesUnsatisfiedStubbing
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#10
  def initialize; end

  # @param dry_call [Mocktail::Call]
  # @return [Mocktail::UnsatisfyingCall]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/describes_unsatisfied_stubbing.rb#14
  def describe(dry_call); end
end

# source://mocktail//lib/mocktail/share/determines_matching_calls.rb#6
class Mocktail::DeterminesMatchingCalls
  # @param real_call [Call]
  # @param demo_call [Call]
  # @param demo_config [DemoConfig]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#9
  def determine(real_call, demo_call, demo_config); end

  private

  # @param real_args [Array<T.untyped>]
  # @param demo_args [Array<T.untyped>]
  # @param ignore_extra_args [Boolean]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#21
  def args_match?(real_args, demo_args, ignore_extra_args); end

  # @param real_block [Proc, nil]
  # @param demo_block [Proc, nil]
  # @param ignore_block [Boolean]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#46
  def blocks_match?(real_block, demo_block, ignore_block); end

  # @param real_kwargs [Hash{Symbol => T.untyped}]
  # @param demo_kwargs [Hash{Symbol => T.untyped}]
  # @param ignore_extra_args [Boolean]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#34
  def kwargs_match?(real_kwargs, demo_kwargs, ignore_extra_args); end

  # @param real_arg [T.untyped]
  # @param demo_arg [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/share/determines_matching_calls.rb#58
  def match?(real_arg, demo_arg); end
end

# source://mocktail//lib/mocktail/value/double.rb#4
class Mocktail::Double < ::T::Struct
  const :original_type, T.any(::Module, T::Class[T.anything])
  const :dry_type, T::Class[T.anything]
  const :dry_instance, T.untyped
  const :dry_methods, T::Array[::Symbol]

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/double_data.rb#7
class Mocktail::DoubleData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :type, T.any(::Module, T::Class[T.anything])
  const :double, T.untyped
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.anything]]

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/explanation.rb#30
class Mocktail::DoubleExplanation < ::Mocktail::Explanation
  # @param reference [DoubleData]
  # @param message [String]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#33
  def initialize(reference, message); end

  # @return [DoubleData]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#31
  def reference; end
end

# source://mocktail//lib/mocktail/imitates_type/ensures_imitation_support.rb#4
class Mocktail::EnsuresImitationSupport
  # @param type [T::Class[T.anything], Module]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/imitates_type/ensures_imitation_support.rb#7
  def ensure(type); end
end

# source://mocktail//lib/mocktail/errors.rb#4
class Mocktail::Error < ::StandardError; end

# source://mocktail//lib/mocktail/explains_nils.rb#7
class Mocktail::ExplainsNils
  # @return [void] a new instance of ExplainsNils
  #
  # source://mocktail//lib/mocktail/explains_nils.rb#10
  def initialize; end

  # @return [Array<UnsatisfyingCallExplanation>]
  #
  # source://mocktail//lib/mocktail/explains_nils.rb#15
  def explain; end
end

# source://mocktail//lib/mocktail/explains_thing.rb#7
class Mocktail::ExplainsThing
  # @return [void] a new instance of ExplainsThing
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#10
  def initialize; end

  # @param thing [Object]
  # @return [Explanation]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#15
  def explain(thing); end

  private

  # @param double [Double]
  # @return [DoubleData]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#50
  def data_for_double(double); end

  # @param type_replacement [TypeReplacement]
  # @return [TypeReplacementData]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#72
  def data_for_type_replacement(type_replacement); end

  # @param double_data [DoubleData, TypeReplacementData]
  # @param method [Symbol]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#98
  def describe_dry_method(double_data, method); end

  # @param double [Double]
  # @return [DoubleExplanation]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#59
  def double_explanation(double); end

  # @param thing [Object]
  # @return [FakeMethodExplanation, nil]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#30
  def fake_method_explanation_for(thing); end

  # @param thing [Object]
  # @return [NoExplanation]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#123
  def no_explanation(thing); end

  # @param type_replacement [TypeReplacement]
  # @return [ReplacedTypeExplanation]
  #
  # source://mocktail//lib/mocktail/explains_thing.rb#85
  def replaced_type_explanation(type_replacement); end
end

# source://mocktail//lib/mocktail/value/explanation.rb#4
class Mocktail::Explanation
  # @param reference [Mocktail::ExplanationData]
  # @param message [String]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#11
  def initialize(reference, message); end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#9
  def message; end

  # @return [Mocktail::ExplanationData]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#7
  def reference; end

  # @return [T.class_of(Explanation)]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#16
  def type; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://mocktail//lib/mocktail/value/explanation_data.rb#4
module Mocktail::ExplanationData
  include ::Kernel

  # @abstract
  # @return [Array<Mocktail::Call>]
  #
  # source://mocktail//lib/mocktail/value/explanation_data.rb#10
  def calls; end

  # @abstract
  # @return [Array<Mocktail::Stubbing[T.anything]>]
  #
  # source://mocktail//lib/mocktail/value/explanation_data.rb#13
  def stubbings; end
end

# source://mocktail//lib/mocktail/value/fake_method_data.rb#4
class Mocktail::FakeMethodData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :receiver, T.anything
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.anything]]

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/explanation.rb#48
class Mocktail::FakeMethodExplanation < ::Mocktail::Explanation
  # @param reference [FakeMethodData]
  # @param message [String]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#51
  def initialize(reference, message); end

  # @return [FakeMethodData]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#49
  def reference; end
end

# source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#6
class Mocktail::FindsSatisfaction
  # @return [void] a new instance of FindsSatisfaction
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#9
  def initialize; end

  # @param dry_call [Call]
  # @return [Stubbing[T.anything], nil]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing/finds_satisfaction.rb#13
  def find(dry_call); end
end

# source://mocktail//lib/mocktail/verifies_call/finds_verifiable_calls.rb#6
class Mocktail::FindsVerifiableCalls
  # @return [void]
  #
  # source://mocktail//lib/mocktail/verifies_call/finds_verifiable_calls.rb#9
  def initialize; end

  # @param recording [Call]
  # @param demo_config [DemoConfig]
  # @return [Array<Call>]
  #
  # source://mocktail//lib/mocktail/verifies_call/finds_verifiable_calls.rb#13
  def find(recording, demo_config); end
end

# source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#7
class Mocktail::FulfillsStubbing
  # @return [void] a new instance of FulfillsStubbing
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#10
  def initialize; end

  # @param dry_call [Call]
  # @return [T.anything]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#15
  def fulfill(dry_call); end

  # @param dry_call [Call]
  # @return [Stubbing[T.anything], nil]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#25
  def satisfaction(dry_call); end

  private

  # @param dry_call [Call]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/fulfills_stubbing.rb#33
  def store_unsatisfying_call!(dry_call); end
end

# source://mocktail//lib/mocktail/verifies_call/raises_verification_error/gathers_calls_of_method.rb#4
class Mocktail::GathersCallsOfMethod
  # @param dry_call [Call]
  # @return [Array<Call>]
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error/gathers_calls_of_method.rb#7
  def gather(dry_call); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#4
class Mocktail::GathersFakeableInstanceMethods
  # @param type [T::Class[T.anything], Module]
  # @return [Array<Symbol>]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#7
  def gather(type); end

  # @param type [T::Class[T.anything], Module]
  # @param method_name [Symbol]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#17
  def ignore?(type, method_name); end

  # @return [Array<Module>]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/gathers_fakeable_instance_methods.rb#21
  def ignored_ancestors; end
end

# source://mocktail//lib/mocktail/grabs_original_method_parameters.rb#4
class Mocktail::GrabsOriginalMethodParameters
  # Sorbet wraps the original method in a sig wrapper, so we need to unwrap it.
  # The value returned from `owner.instance_method(method_name)` does not have
  # the real parameters values available, as they'll have been erased
  #
  # If the method isn't wrapped by Sorbet, this will return the #instance_method,
  # per usual
  #
  # @param method [UnboundMethod, Method, nil]
  # @return [Array<Array<Symbol>>]
  #
  # source://mocktail//lib/mocktail/grabs_original_method_parameters.rb#14
  def grab(method); end

  private

  # @param method [UnboundMethod, Method]
  # @return [T::Private::Methods::Signature, nil]
  #
  # source://mocktail//lib/mocktail/grabs_original_method_parameters.rb#26
  def sorbet_wrapped_method(method); end
end

# source://mocktail//lib/mocktail/handles_dry_call.rb#8
class Mocktail::HandlesDryCall
  # @return [void] a new instance of HandlesDryCall
  #
  # source://mocktail//lib/mocktail/handles_dry_call.rb#11
  def initialize; end

  # @param dry_call [Call]
  # @return [T.anything]
  #
  # source://mocktail//lib/mocktail/handles_dry_call.rb#17
  def handle(dry_call); end
end

# source://mocktail//lib/mocktail/handles_dry_new_call.rb#4
class Mocktail::HandlesDryNewCall
  # @return [void] a new instance of HandlesDryNewCall
  #
  # source://mocktail//lib/mocktail/handles_dry_new_call.rb#7
  def initialize; end

  # @param type [T::Class[T.anything]]
  # @param args [Array<T.anything>]
  # @param kwargs [Hash{Symbol => T.anything}]
  # @param block [Proc, nil]
  # @return [T.anything]
  #
  # source://mocktail//lib/mocktail/handles_dry_new_call.rb#14
  def handle(type, args, kwargs, block); end
end

# source://mocktail//lib/mocktail/imitates_type.rb#7
class Mocktail::ImitatesType
  # @return [void] a new instance of ImitatesType
  #
  # source://mocktail//lib/mocktail/imitates_type.rb#11
  def initialize; end

  # @param type [T::Class[T.type_parameter(:T)]]
  # @return [T.type_parameter(:T)]
  #
  # source://mocktail//lib/mocktail/imitates_type.rb#16
  def imitate(type); end
end

# source://mocktail//lib/mocktail/initializes_mocktail.rb#4
class Mocktail::InitializesMocktail
  # @return [void]
  #
  # source://mocktail//lib/mocktail/initializes_mocktail.rb#7
  def init; end
end

# source://mocktail//lib/mocktail/errors.rb#14
class Mocktail::InvalidMatcherError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/handles_dry_call/logs_call.rb#4
class Mocktail::LogsCall
  # @param dry_call [Call]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/logs_call.rb#7
  def log(dry_call); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double.rb#7
class Mocktail::MakesDouble
  # @return [void] a new instance of MakesDouble
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double.rb#10
  def initialize; end

  # @param type [T::Class[T.anything]]
  # @return [Double]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double.rb#15
  def make(type); end
end

# source://mocktail//lib/mocktail/matcher_presentation.rb#4
class Mocktail::MatcherPresentation
  sig { returns(T.untyped) }
  def any; end

  sig { type_parameters(:T).params(expecteds: T.type_parameter(:T)).returns(T::Array[T.type_parameter(:T)]) }
  def includes(*expecteds); end

  sig do
    type_parameters(:K, :V)
      .params(
        expecteds: T::Hash[T.type_parameter(:K), T.type_parameter(:V)]
      ).returns(T::Hash[T.type_parameter(:K), T.type_parameter(:V)])
  end
  def includes_hash(*expecteds); end

  sig do
    type_parameters(:K, :V)
      .params(
        expecteds: T.type_parameter(:K)
      ).returns(T::Hash[T.type_parameter(:K), T.type_parameter(:V)])
  end
  def includes_key(*expecteds); end

  sig { type_parameters(:T).params(expecteds: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def includes_string(*expecteds); end

  sig { type_parameters(:T).params(expected: T::Class[T.type_parameter(:T)]).returns(T.type_parameter(:T)) }
  def is_a(expected); end

  sig { params(pattern: T.any(String, Regexp)).returns(String) }
  def matches(pattern); end

  # @param name [Symbol]
  # @param args [T.anything]
  # @param kwargs [T.anything]
  # @param blk [Proc, nil]
  # @return [T.anything]
  #
  # source://mocktail//lib/mocktail/matcher_presentation.rb#11
  def method_missing(name, *args, **kwargs, &blk); end

  sig { type_parameters(:T).params(unexpected: T.type_parameter(:T)).returns(T.type_parameter(:T)) }
  def not(unexpected); end

  sig { returns(T.untyped) }
  def numeric; end

  sig { params(blk: T.proc.params(arg: T.untyped).returns(T::Boolean)).returns(T.untyped) }
  def that(&blk); end

  private

  # @param name [Symbol]
  # @param include_private [Boolean]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matcher_presentation.rb#7
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://mocktail//lib/mocktail/value/matcher_registry.rb#4
class Mocktail::MatcherRegistry
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/matcher_registry.rb#11
  def initialize; end

  # @param matcher_type [T.class_of(Matchers::Base)]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/matcher_registry.rb#15
  def add(matcher_type); end

  # @param name [Symbol]
  # @return [T.class_of(Matchers::Base), nil]
  #
  # source://mocktail//lib/mocktail/value/matcher_registry.rb#19
  def get(name); end

  class << self
    # @return [MatcherRegistry]
    #
    # source://mocktail//lib/mocktail/value/matcher_registry.rb#7
    def instance; end
  end
end

# source://mocktail//lib/mocktail/matchers.rb#4
module Mocktail::Matchers; end

# source://mocktail//lib/mocktail/matchers/any.rb#4
class Mocktail::Matchers::Any < ::Mocktail::Matchers::Base
  # @return [void] a new instance of Any
  #
  # source://mocktail//lib/mocktail/matchers/any.rb#11
  def initialize; end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/matchers/any.rb#19
  def inspect; end

  # @param actual [T.anything]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/any.rb#15
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/any.rb#7
    def matcher_name; end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://mocktail//lib/mocktail/matchers/base.rb#4
class Mocktail::Matchers::Base
  # Custom matchers can receive any args, kwargs, or block they want. Usually
  # single-argument, though, so that's defaulted here and in #insepct
  #
  # @param expected [BasicObject]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#15
  def initialize(expected); end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#27
  def inspect; end

  # @return [true]
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#31
  def is_mocktail_matcher?; end

  # @param actual [T.untyped]
  # @raise [Mocktail::InvalidMatcherError]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/base.rb#23
  def match?(actual); end

  class << self
    # @raise [Mocktail::InvalidMatcherError]
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/base.rb#19
    def matcher_name; end
  end
end

# Captors are conceptually complex implementations, but with a simple usage/purpose:
# They are values the user can create and hold onto that will return a matcher
# and then "capture" the value made by the real call, for later analysis & assertion.
#
# Unlike other matchers, these don't make any useful sense for stubbing, but are
# very useful when asserting complication call verifications
#
# The fact the user will need the reference outside the verification call is
# why this is a top-level method on Mocktail, and not included in the |m| block
# arg to stubs/verify
#
# See Mockito, which is the earliest implementation I know of:
# https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Captor.html
#
# source://mocktail//lib/mocktail/matchers/captor.rb#17
class Mocktail::Matchers::Captor
  # @return [void] a new instance of Captor
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#55
  def initialize; end

  # This T.untyped is intentional. Even though a Capture is surely returned,
  # in order for a verification demonstration to pass its own type check,
  # it needs to think it's being returned whatever parameter is expected
  #
  # @return [T.untyped]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#53
  def capture; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#59
  def captured?; end

  # @return [T.untyped]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#63
  def value; end
end

# source://mocktail//lib/mocktail/matchers/captor.rb#20
class Mocktail::Matchers::Captor::Capture < ::Mocktail::Matchers::Base
  # @return [void] a new instance of Capture
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#29
  def initialize; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#40
  def captured?; end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#44
  def inspect; end

  # @param actual [T.untyped]
  # @return [true]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#34
  def match?(actual); end

  # Returns the value of attribute value.
  #
  # @return [T.untyped]
  #
  # source://mocktail//lib/mocktail/matchers/captor.rb#27
  def value; end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/captor.rb#23
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes.rb#4
class Mocktail::Matchers::Includes < ::Mocktail::Matchers::Base
  # @param expecteds [T.untyped]
  # @return [void] a new instance of Includes
  #
  # source://mocktail//lib/mocktail/matchers/includes.rb#11
  def initialize(*expecteds); end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/matchers/includes.rb#24
  def inspect; end

  # @param actual [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/includes.rb#15
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/includes.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes_hash.rb#4
class Mocktail::Matchers::IncludesHash < ::Mocktail::Matchers::Includes
  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/includes_hash.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes_key.rb#4
class Mocktail::Matchers::IncludesKey < ::Mocktail::Matchers::Includes
  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/includes_key.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/includes_string.rb#4
class Mocktail::Matchers::IncludesString < ::Mocktail::Matchers::Includes
  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/includes_string.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/is_a.rb#4
class Mocktail::Matchers::IsA < ::Mocktail::Matchers::Base
  # @param actual [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/is_a.rb#11
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/is_a.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/matches.rb#4
class Mocktail::Matchers::Matches < ::Mocktail::Matchers::Base
  # @param actual [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/matches.rb#11
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/matches.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/not.rb#4
class Mocktail::Matchers::Not < ::Mocktail::Matchers::Base
  # @param actual [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/not.rb#11
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/not.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/numeric.rb#4
class Mocktail::Matchers::Numeric < ::Mocktail::Matchers::Base
  # @return [void] a new instance of Numeric
  #
  # source://mocktail//lib/mocktail/matchers/numeric.rb#11
  def initialize; end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/matchers/numeric.rb#19
  def inspect; end

  # @param actual [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/numeric.rb#15
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/numeric.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/matchers/that.rb#4
class Mocktail::Matchers::That < ::Mocktail::Matchers::Base
  # @param blk [T.proc.params(actual: T.untyped).returns(T.untyped), nil]
  # @return [void] a new instance of That
  #
  # source://mocktail//lib/mocktail/matchers/that.rb#11
  def initialize(&blk); end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/matchers/that.rb#24
  def inspect; end

  # @param actual [T.untyped]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/matchers/that.rb#18
  def match?(actual); end

  class << self
    # @return [Symbol]
    #
    # source://mocktail//lib/mocktail/matchers/that.rb#7
    def matcher_name; end
  end
end

# source://mocktail//lib/mocktail/errors.rb#10
class Mocktail::MissingDemonstrationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/value/explanation.rb#21
class Mocktail::NoExplanation < ::Mocktail::Explanation
  # @param reference [NoExplanationData]
  # @param message [String]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#24
  def initialize(reference, message); end

  # @return [NoExplanationData]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#22
  def reference; end
end

# source://mocktail//lib/mocktail/value/no_explanation_data.rb#4
class Mocktail::NoExplanationData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :thing, T.untyped

  # @raise [Error]
  # @return [Array<Mocktail::Call>]
  #
  # source://mocktail//lib/mocktail/value/no_explanation_data.rb#10
  def calls; end

  # @raise [Error]
  # @return [Array<Mocktail::Stubbing[T.anything]>]
  #
  # source://mocktail//lib/mocktail/value/no_explanation_data.rb#14
  def stubbings; end

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/signature.rb#4
class Mocktail::Params < ::T::Struct
  prop :all, T::Array[::Symbol], default: T.unsafe(nil)
  prop :required, T::Array[::Symbol], default: T.unsafe(nil)
  prop :optional, T::Array[::Symbol], default: T.unsafe(nil)
  prop :rest, T.nilable(::Symbol)

  # @return [Array<Symbol>]
  #
  # source://mocktail//lib/mocktail/value/signature.rb#12
  def allowed; end

  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/signature.rb#16
  def rest?; end

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#8
class Mocktail::RaisesNeatoNoMethodError
  # @return [void] a new instance of RaisesNeatoNoMethodError
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#11
  def initialize; end

  # @param call [Call]
  # @raise [NoMethodError]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#17
  def call(call); end

  private

  # @param block [Proc, nil]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#57
  def block_param(block); end

  # @param call [Call]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#73
  def corrections(call); end

  # @param identifiers [Array<String>]
  # @return [Array<String>]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#63
  def count_repeats(identifiers); end

  # @param kwargs [Hash{Symbol => T.anything}]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#51
  def kwparams_list(kwargs); end

  # @param call [Call]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#33
  def params(call); end

  # @param args [Array<T.anything>]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/raises_neato_no_method_error.rb#43
  def params_list(args); end
end

# source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#8
class Mocktail::RaisesVerificationError
  # @return [void]
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#11
  def initialize; end

  # @param recording [Call]
  # @param verifiable_calls [Array<Call>]
  # @param demo_config [DemoConfig]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#17
  def raise(recording, verifiable_calls, demo_config); end

  private

  # @param recording [Call]
  # @param verifiable_calls [Array<Call>]
  # @param demo_config [DemoConfig]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#46
  def describe_other_calls(recording, verifiable_calls, demo_config); end

  # @param demo_config [DemoConfig]
  # @param count [Integer]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#36
  def describe_verifiable_times_called(demo_config, count); end

  # @param s [String]
  # @param count [Integer, nil]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/verifies_call/raises_verification_error.rb#61
  def pl(s, count); end
end

# source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#4
class Mocktail::ReconcilesArgsWithParams
  # @param signature [Signature]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#7
  def reconcile(signature); end

  private

  # @param arg_params [Params]
  # @param args [Array<T.untyped>]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#14
  def args_match?(arg_params, args); end

  # @param kwarg_params [Params]
  # @param kwargs [Hash{Symbol => T.untyped}]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/reconciles_args_with_params.rb#19
  def kwargs_match?(kwarg_params, kwargs); end
end

# source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#4
class Mocktail::ReconstructsCall
  # @param double [Object]
  # @param call_binding [Binding]
  # @param default_args [Hash{Symbol => T.anything}, nil]
  # @param dry_class [T::Class[Object]]
  # @param type [Module, T::Class[T.anything]]
  # @param method [Symbol]
  # @param original_method [UnboundMethod, Method]
  # @param signature [Signature]
  # @return [Call]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#7
  def reconstruct(double:, call_binding:, default_args:, dry_class:, type:, method:, original_method:, signature:); end

  private

  # @param signature [Signature]
  # @param call_binding [Binding]
  # @param default_args [Hash{Symbol => T.anything}, nil]
  # @return [Array<T.anything>]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#23
  def args_for(signature, call_binding, default_args); end

  # @param signature [Signature]
  # @param call_binding [Binding]
  # @param default_args [Hash{Symbol => T.anything}, nil]
  # @return [Hash{Symbol => T.anything}]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#32
  def kwargs_for(signature, call_binding, default_args); end

  # @param params [Params]
  # @param default_args [Hash{Symbol => T.anything}, nil]
  # @return [Array(Array<Symbol>, [Symbol, nil])]
  #
  # source://mocktail//lib/mocktail/imitates_type/makes_double/declares_dry_class/reconstructs_call.rb#41
  def non_default_args(params, default_args); end
end

# source://mocktail//lib/mocktail/records_demonstration.rb#4
class Mocktail::RecordsDemonstration
  # @param demonstration [T.proc.params(matchers: Mocktail::MatcherPresentation).returns(T.type_parameter(:T))]
  # @param demo_config [DemoConfig]
  # @return [Call]
  #
  # source://mocktail//lib/mocktail/records_demonstration.rb#7
  def record(demonstration, demo_config); end
end

# source://mocktail//lib/mocktail/simulates_argument_error/recreates_message.rb#4
class Mocktail::RecreatesMessage
  # @param signature [Signature]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/recreates_message.rb#7
  def recreate(signature); end
end

# source://mocktail//lib/mocktail/replaces_type/redefines_new.rb#4
class Mocktail::RedefinesNew
  # @return [void] a new instance of RedefinesNew
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_new.rb#7
  def initialize; end

  # @param type [T::Class[T.anything], Module]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_new.rb#11
  def redefine(type); end
end

# source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#4
class Mocktail::RedefinesSingletonMethods
  # @return [void] a new instance of RedefinesSingletonMethods
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#7
  def initialize; end

  # @param type [T::Class[T.anything], Module]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#44
  def declare_singleton_method_missing_errors!(type); end

  # @param type [T::Class[T.anything], Module]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#11
  def redefine(type); end

  private

  # @param method [Method]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/replaces_type/redefines_singleton_methods.rb#68
  def sorbet_method_hook?(method); end
end

# source://mocktail//lib/mocktail/registers_matcher.rb#4
class Mocktail::RegistersMatcher
  # @return [void] a new instance of RegistersMatcher
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#7
  def initialize; end

  # @param matcher_type [T.class_of(Matchers::Base)]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#11
  def register(matcher_type); end

  private

  # @param matcher_type [T.class_of(Matchers::Base)]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#53
  def invalid_flag?(matcher_type); end

  # @param matcher_type [T.class_of(Matchers::Base)]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#46
  def invalid_match?(matcher_type); end

  # @param matcher_type [T.class_of(Matchers::Base)]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#39
  def invalid_name?(matcher_type); end

  # @param matcher_type [T.class_of(Matchers::Base)]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/registers_matcher.rb#35
  def invalid_type?(matcher_type); end
end

# source://mocktail//lib/mocktail/registers_stubbing.rb#6
class Mocktail::RegistersStubbing
  # @return [void] a new instance of RegistersStubbing
  #
  # source://mocktail//lib/mocktail/registers_stubbing.rb#9
  def initialize; end

  # @param demonstration [T.proc.params(matchers: Mocktail::MatcherPresentation).returns(T.type_parameter(:T))]
  # @param demo_config [DemoConfig]
  # @return [Mocktail::Stubbing[T.type_parameter(:T)]]
  #
  # source://mocktail//lib/mocktail/registers_stubbing.rb#13
  def register(demonstration, demo_config); end
end

# source://mocktail//lib/mocktail/value/explanation.rb#39
class Mocktail::ReplacedTypeExplanation < ::Mocktail::Explanation
  # @param reference [TypeReplacementData]
  # @param message [String]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#42
  def initialize(reference, message); end

  # @return [TypeReplacementData]
  #
  # source://mocktail//lib/mocktail/value/explanation.rb#40
  def reference; end
end

# source://mocktail//lib/mocktail/replaces_next.rb#4
class Mocktail::ReplacesNext
  # @return [void] a new instance of ReplacesNext
  #
  # source://mocktail//lib/mocktail/replaces_next.rb#7
  def initialize; end

  # @param type [T::Class[T.all(T.type_parameter(:T), Object)]]
  # @param count [Integer]
  # @raise [UnsupportedMocktail]
  # @return [Array<T.type_parameter(:T)>]
  #
  # source://mocktail//lib/mocktail/replaces_next.rb#17
  def replace(type, count); end

  # @param type [T::Class[T.all(T.type_parameter(:T), Object)]]
  # @return [T.type_parameter(:T)]
  #
  # source://mocktail//lib/mocktail/replaces_next.rb#13
  def replace_once(type); end
end

# source://mocktail//lib/mocktail/replaces_type.rb#8
class Mocktail::ReplacesType
  # @return [void] a new instance of ReplacesType
  #
  # source://mocktail//lib/mocktail/replaces_type.rb#11
  def initialize; end

  # @param type [T::Class[T.anything], Module]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/replaces_type.rb#18
  def replace(type); end
end

# source://mocktail//lib/mocktail/resets_state.rb#4
class Mocktail::ResetsState
  # @return [void]
  #
  # source://mocktail//lib/mocktail/resets_state.rb#7
  def reset; end
end

# source://mocktail//lib/mocktail/replaces_type/runs_sorbet_sig_blocks_before_replacement.rb#4
class Mocktail::RunsSorbetSigBlocksBeforeReplacement
  # This is necessary because when Sorbet runs a sig block of a singleton
  # method, it has the net effect of unwrapping/redefining the method. If
  # we try to use Mocktail.replace(Foo) and Foo.bar has a Sorbet sig block,
  # then we'll end up with three "versions" of the same method and no way
  # to keep straight which one == which:
  #
  #  A - Foo.bar, as defined in the original class
  #  B - Foo.bar, as redefined by RedefinesSingletonMethods
  #  C - Foo.bar, as wrapped by sorbet-runtime
  #
  # Initially, Foo.method(:bar) would == C, but after the type
  # replacement, it would == B (with a reference back to C as the original),
  # but after while handling a single dry call, our invocation of
  # GrabsOriginalMethodParameters.grab(Foo.method(:bar)) would invoke the
  # Sorbet `sig` block, which has the net effect of redefining the method back
  # to A.
  #
  # It's very fun and confusing and a great time.
  #
  # @param type [T::Class[T.anything], Module]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/replaces_type/runs_sorbet_sig_blocks_before_replacement.rb#26
  def run(type); end
end

# source://mocktail//lib/mocktail/value/signature.rb#21
class Mocktail::Signature < ::T::Struct
  const :positional_params, ::Mocktail::Params
  const :positional_args, T::Array[T.anything]
  const :keyword_params, ::Mocktail::Params
  const :keyword_args, T::Hash[::Symbol, T.anything]
  const :block_param, T.nilable(::Symbol)
  const :block_arg, T.nilable(::Proc), default: T.unsafe(nil)

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/signature.rb#31
Mocktail::Signature::DEFAULT_BLOCK_PARAM = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/value/signature.rb#29
Mocktail::Signature::DEFAULT_REST_ARGS = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/value/signature.rb#30
Mocktail::Signature::DEFAULT_REST_KWARGS = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/simulates_argument_error.rb#10
class Mocktail::SimulatesArgumentError
  # @return [void] a new instance of SimulatesArgumentError
  #
  # source://mocktail//lib/mocktail/simulates_argument_error.rb#13
  def initialize; end

  # @param dry_call [Call]
  # @return [ArgumentError, nil]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error.rb#21
  def simulate(dry_call); end
end

# source://mocktail//lib/mocktail/share/stringifies_call.rb#4
class Mocktail::StringifiesCall
  # @param call [Call]
  # @param anonymous_blocks [Boolean]
  # @param always_parens [Boolean]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#7
  def stringify(call, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  # @param calls [Array<Call>]
  # @param nonzero_message [String]
  # @param zero_message [String]
  # @param anonymous_blocks [Boolean]
  # @param always_parens [Boolean]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#11
  def stringify_multiple(calls, nonzero_message:, zero_message:, anonymous_blocks: T.unsafe(nil), always_parens: T.unsafe(nil)); end

  private

  # @param args [Array<Object>]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#43
  def argify(args); end

  # @param call [Call]
  # @param parens [Boolean]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#27
  def args_to_s(call, parens: T.unsafe(nil)); end

  # @param block [Proc, nil]
  # @param anonymous [Boolean]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#58
  def blockify(block, anonymous:); end

  # @param kwargs [Hash{Symbol => Object}]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#48
  def kwargify(kwargs); end

  # @param block [Proc, nil]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#53
  def lambdafy(block); end

  # @param block [Proc]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#68
  def source_locationify(block); end

  # @param path [String]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/stringifies_call.rb#72
  def strip_pwd(path); end
end

# source://mocktail//lib/mocktail/share/stringifies_method_name.rb#4
class Mocktail::StringifiesMethodName
  # @param call [Call]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/share/stringifies_method_name.rb#7
  def stringify(call); end
end

# source://mocktail//lib/mocktail/stringifies_method_signature.rb#4
class Mocktail::StringifiesMethodSignature
  # @param signature [Signature]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#7
  def stringify(signature); end

  private

  # @param signature [Signature]
  # @return [String]
  #
  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#41
  def block(signature); end

  # @param signature [Signature]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#29
  def keyword(signature); end

  # @param signature [Signature]
  # @return [String, nil]
  #
  # source://mocktail//lib/mocktail/stringifies_method_signature.rb#17
  def positional(signature); end
end

# source://mocktail//lib/mocktail/value/stubbing.rb#4
class Mocktail::Stubbing < ::T::Struct
  extend T::Generic

  const :demonstration, T.proc.params(matchers: ::Mocktail::MatcherPresentation).returns(MethodReturnType)
  const :demo_config, ::Mocktail::DemoConfig
  prop :satisfaction_count, ::Integer, default: T.unsafe(nil)
  const :recording, ::Mocktail::Call
  prop :effect, T.nilable(T.proc.params(call: ::Mocktail::Call).returns(MethodReturnType))

  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/stubbing.rb#15
  def satisfied!; end

  # @param block [T.proc.params(call: Mocktail::Call).returns(MethodReturnType)]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/stubbing.rb#19
  def with(&block); end

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/typed.rb#2
Mocktail::TYPED = T.let(T.unsafe(nil), FalseClass)

# The TopShelf is where we keep all the more global, dangerous state.
# In particular, this is where Mocktail manages state related to singleton
# method replacements carried out with Mocktail.replace(ClassOrModule)
#
# source://mocktail//lib/mocktail/value/top_shelf.rb#7
class Mocktail::TopShelf
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#17
  def initialize; end

  # @param type [Module, T::Class[T.anything]]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#43
  def new_replaced?(type); end

  # @param type [T::Class[T.anything]]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#51
  def of_next_registered?(type); end

  # @param type [Module, T::Class[T.anything]]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#39
  def register_new_replacement!(type); end

  # @param type [T::Class[T.anything]]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#47
  def register_of_next_replacement!(type); end

  # @param type [Module, T::Class[T.anything]]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#59
  def register_singleton_method_replacement!(type); end

  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#35
  def reset_current_thread!; end

  # @param type [Module, T::Class[T.anything]]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#63
  def singleton_methods_replaced?(type); end

  # @param type [Module, T::Class[T.anything]]
  # @return [TypeReplacement]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#23
  def type_replacement_for(type); end

  # @param type [Module, T::Class[T.anything]]
  # @return [TypeReplacement, nil]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#29
  def type_replacement_if_exists_for(type); end

  # @param type [T::Class[T.anything]]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/top_shelf.rb#55
  def unregister_of_next_replacement!(type); end

  class << self
    # @return [TopShelf]
    #
    # source://mocktail//lib/mocktail/value/top_shelf.rb#10
    def instance; end
  end
end

# source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#6
class Mocktail::TransformsParams
  # @return [void] a new instance of TransformsParams
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#9
  def initialize; end

  # @param dry_call [Call]
  # @param params [Array<Array<Symbol>>, nil]
  # @return [Signature]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#13
  def transform(dry_call, params: T.unsafe(nil)); end

  private

  # @param params [Array<Array<Symbol>>]
  # @return [Array<Array<Symbol>>]
  #
  # source://mocktail//lib/mocktail/simulates_argument_error/transforms_params.rb#45
  def name_unnamed_params(params); end
end

# source://mocktail//lib/mocktail/errors.rb#18
class Mocktail::TypeCheckingError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/value/type_replacement.rb#4
class Mocktail::TypeReplacement < ::T::Struct
  const :type, T.any(::Module, T::Class[T.anything])
  prop :original_methods, T.nilable(T::Array[::Method])
  prop :replacement_methods, T.nilable(T::Array[::Method])
  prop :original_new, T.nilable(::Method)
  prop :replacement_new, T.nilable(::Method)

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/type_replacement_data.rb#4
class Mocktail::TypeReplacementData < ::T::Struct
  include ::Mocktail::ExplanationData

  const :type, T.any(::Module, T::Class[T.anything])
  const :replaced_method_names, T::Array[::Symbol]
  const :calls, T::Array[::Mocktail::Call]
  const :stubbings, T::Array[Mocktail::Stubbing[T.anything]]

  # @return [T::Class[T.anything], Module]
  #
  # source://mocktail//lib/mocktail/value/type_replacement_data.rb#14
  def double; end

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/errors.rb#6
class Mocktail::UnexpectedError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/value/unsatisfying_call.rb#4
class Mocktail::UnsatisfyingCall < ::T::Struct
  const :call, ::Mocktail::Call
  const :other_stubbings, T::Array[Mocktail::Stubbing[T.anything]]
  const :backtrace, T::Array[::String]

  class << self
    # source://sorbet-runtime/0.5.10885/lib/types/struct.rb#13
    def inherited(s); end
  end
end

# source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#4
class Mocktail::UnsatisfyingCallExplanation
  # @param reference [UnsatisfyingCall]
  # @param message [String]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#11
  def initialize(reference, message); end

  # @return [String]
  #
  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#9
  def message; end

  # @return [UnsatisfyingCall]
  #
  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#7
  def reference; end

  # @return [T.class_of(UnsatisfyingCallExplanation)]
  #
  # source://mocktail//lib/mocktail/value/unsatisfying_call_explanation.rb#16
  def type; end
end

# source://mocktail//lib/mocktail/errors.rb#8
class Mocktail::UnsupportedMocktail < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/version.rb#11
Mocktail::VERSION = T.let(T.unsafe(nil), String)

# source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#4
class Mocktail::ValidatesArguments
  # @return [void] a new instance of ValidatesArguments
  #
  # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#28
  def initialize; end

  # @param dry_call [Call]
  # @return [nil]
  #
  # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#32
  def validate(dry_call); end

  class << self
    # @return [void]
    #
    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#7
    def disable!; end

    # @return [Boolean]
    #
    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#15
    def disabled?; end

    # @return [void]
    #
    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#11
    def enable!; end

    # @param disable [Boolean, nil]
    # @param blk [T.proc.returns(T.anything)]
    # @return [void]
    #
    # source://mocktail//lib/mocktail/handles_dry_call/validates_arguments.rb#19
    def optional(disable, &blk); end
  end
end

# source://mocktail//lib/mocktail/errors.rb#16
class Mocktail::VerificationError < ::Mocktail::Error; end

# source://mocktail//lib/mocktail/verifies_call.rb#8
class Mocktail::VerifiesCall
  # @return [void]
  #
  # source://mocktail//lib/mocktail/verifies_call.rb#11
  def initialize; end

  # @param demo [T.proc.params(matchers: Mocktail::MatcherPresentation).void]
  # @param demo_config [DemoConfig]
  # @return [void]
  #
  # source://mocktail//lib/mocktail/verifies_call.rb#17
  def verify(demo, demo_config); end

  private

  # @param verifiable_call_count [Integer]
  # @param demo_config [DemoConfig]
  # @return [Boolean]
  #
  # source://mocktail//lib/mocktail/verifies_call.rb#29
  def verification_satisfied?(verifiable_call_count, demo_config); end
end

# sorbet gem fails to export some of these constants, so we need to in order to
# pass static typecheck
module T
  module Private
    module Methods
      module MethodHooks; end

      class Signature
        sig { returns(T::Array[T::Array[Symbol]]) }
        def parameters; end
      end

      module SingletonMethodHooks; end
    end

    module RuntimeLevels
      class << self
        sig { returns(Symbol) }
        def default_checked_level; end
      end
    end
  end
end

module Mocktail::ExplanationData
  include Kernel
end

class Mocktail::Stubbing
  MethodReturnType = type_member
end
